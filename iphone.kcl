// iPhone 16 Pro 3D model
// For technical specifications, see page 296-299
// https://developer.apple.com/accessories/Accessory-Design-Guidelines.pdf


cornerCurveRadius = 19.23
totalWidth = 71.45
totalLength = 149.61
bodyLength = -totalLength + cornerCurveRadius * 2

edgeCurveHeight = 2.28
totalThickness = 8.25
bodyThickness = totalThickness - (edgeCurveHeight * 2)

lengthWithoutCurve = totalLength - (cornerCurveRadius * 2)
widthWithoutCurve = totalWidth - (cornerCurveRadius * 2)

edgeCurveWidth = 2.41
widthWithoutEdgeCurve = totalWidth - (edgeCurveWidth * 2)

// 0th and every third point are documented points.
// intermediate points are interpolated
// TODO: migrate python midpoint interpolation to KCL
cornerCurvePoints = [
  [0, 19.23],
  [0.01, 17.41],
  [0.02, 15.58],
  [0.04, 13.75],
  [0.17, 11.92],
  [0.43, 10.12],
  [0.89, 8.36],
  [1.6, 6.68],
  [2.56, 5.13],
  [3.74, 3.74],
  [5.13, 2.56],
  [6.68, 1.6],
  [8.36, 0.89],
  [10.12, 0.43],
  [11.92, 0.17],
  [13.75, 0.04],
  [15.58, 0.02],
  [17.41, 0.01],
  [19.23, 0]
]

// offset returns the relative difference between two points in a list
fn offsetFunc(pts, startIndex, endIndex) {
  r0 = pts[startIndex]
  xx0 = r0[0]
  yy0 = r0[1]
  r1 = pts[endIndex]
  xx1 = r1[0]
  yy1 = r1[1]
  return [xx1 - xx0, yy1 - yy0]
}

// rotatedOffset returns the relative difference between two points in a list, rotated 90 degrees
fn rotatedOffset90Func(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [-offsetRes[1], offsetRes[0]]
}

// rotatedOffset180 returns the relative difference between two points in a list, rotated 180 degrees
fn rotatedOffset180Func(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [-offsetRes[0], -offsetRes[1]]
}

// rotatedOffset270 returns the relative difference between two points in a list, rotated 270 degrees
fn rotatedOffset270Func(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [offsetRes[1], -offsetRes[0]]
}

// cornerBezierCurves returns siz corner bezier curves
fn cornerBezierCurves(pts, offsetFunc, z) {
  return bezierCurve({
         to = offsetFunc(pts, 0, 3),
         control1 = offsetFunc(pts, 0, 1),
         control2 = offsetFunc(pts, 0, 2)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 3, 6),
         control1 = offsetFunc(pts, 3, 4),
         control2 = offsetFunc(pts, 3, 5)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 6, 9),
         control1 = offsetFunc(pts, 6, 7),
         control2 = offsetFunc(pts, 6, 8)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 9, 12),
         control1 = offsetFunc(pts, 9, 10),
         control2 = offsetFunc(pts, 9, 11)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 12, 15),
         control1 = offsetFunc(pts, 12, 13),
         control2 = offsetFunc(pts, 12, 14)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 15, 18),
         control1 = offsetFunc(pts, 15, 16),
         control2 = offsetFunc(pts, 15, 17)
       }, %)
}

// generate iphone body
fn iphoneBody(x, y, z) {
  return startSketchOn(offsetPlane('XY', offset = z))
    |> startProfileAt([x, y], %)
    |> yLine(-lengthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, offsetFunc, %)
    |> xLine(widthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffset90Func, %)
    |> yLine(lengthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffset180Func, %)
    |> xLine(-widthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffset270Func, %)
    |> close()
    |> extrude(length = bodyThickness)
}

phoneBody = iphoneBody(0, 0, 0)

// center fill
startSketchOn(offsetPlane('XY', offset = -edgeCurveHeight))
    |> startProfileAt([cornerCurveRadius, 0], %)
    |> xLine(widthWithoutCurve, %)
    |> yLine(-lengthWithoutCurve, %)
    |> xLine(-widthWithoutCurve, %)
    |> close()
    |> extrude( length = totalThickness )

// -------------- Edge --------------
// Edge curve points from diagram
edgePoints = [
  [0, 0.0],
  [0.07, 1.02],
  [0.58, 1.92],
  [1.47, 2.26],
  [2.41, 2.28]
]

// 0th and every third point are documented points.
// intermediate points are interpolated
// TODO: migrate python midpoint interpolation to KCL
moreEdgePoints = [
  [0, 0.0],
  [0.0, 0.34],
  [0.01, 0.68],
  [0.07, 1.02],
  [0.18, 1.36],
  [0.36, 1.67],
  [0.58, 1.92],
  [0.85, 2.1],
  [1.15, 2.2],
  [1.47, 2.26],
  [1.79, 2.28],
  [2.1, 2.28],
  [2.41, 2.28]
]

fn reversePts(xy) {
  return [-xy[0], xy[1]]
}

fn reversePtsY(xy) {
  return [-xy[0], -xy[1]]
}

fn negativeY(xYpts) {
  return [xYpts[0], -xYpts[1]]
}

fn negativeX(xYpts) {
  return [-xYpts[0], xYpts[1]]
}

fn edgeBezCurves(pts, offsetFunc, z) {
  return bezierCurve({
         to = offsetFunc(pts, 0, 3),
         control1 = offsetFunc(pts, 0, 1),
         control2 = offsetFunc(pts, 0, 2)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 3, 6),
         control1 = offsetFunc(pts, 3, 4),
         control2 = offsetFunc(pts, 3, 5)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 6, 9),
         control1 = offsetFunc(pts, 6, 7),
         control2 = offsetFunc(pts, 6, 8)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 9, 12),
         control1 = offsetFunc(pts, 9, 10),
         control2 = offsetFunc(pts, 9, 11)
       }, %)
}

fn reverseOffset(pts, startIndex, endIndex) {
  return offsetFunc(pts, startIndex, endIndex)
    |> reversePts(%)
}

fn reverseOffsetY(pts, startIndex, endIndex) {
  return offsetFunc(pts, startIndex, endIndex)
    |> reversePtsY(%)
}

fn reverseRotatedOffset180(pts, startIndex, endIndex) {
  return rotatedOffset180Func(pts, startIndex, endIndex)
    |> reversePts(%)
}

fn edgeCurves(points, x, y, z) {
  rad = cornerCurveRadius - edgeCurveWidth
  return startSketchOn(offsetPlane('XZ', offset = z))
    |> startProfileAt([x, y], %)
    |> edgeBezCurves(points, offsetFunc, %)
    |> xLine(-rad, %)
    |> yLine(-edgeCurveHeight, %)
    |> close()
}


fn negativeYList(pts) {
  return map(pts, negativeY)
}

fn negativeXList(pts) {
  return map(pts, negativeX)
}

fn negativeXYList(pts) {
  return negativeYList(negativeXList(pts))
}

fn identity(pts) {
  return pts
}

fn invert(x) {
  return -x
}

fn pairOffsetxy(pair, x, y) {
  return [pair[0] + x, pair[1] + y]
}
fn pairOffsetX(xy, xOffset) {
  return pairOffsetxy(xy, xOffset, 0)
}
fn pairOffsetY(xy, yOffset) {
  return pairOffsetxy(xy, 0, yOffset)
}

// Generate a bezier curve segment for a sweep Path
fn generateBezierCurve(pts, offsetFunc, ptIdx, z) {
  return bezierCurve({
    to = offsetFunc(pts, ptIdx, ptIdx + 3),
    control1 = offsetFunc(pts, ptIdx, ptIdx + 1),
    control2 = offsetFunc(pts, ptIdx, ptIdx + 2)
  }, %)
}

fn generateEdgeCornerCurves(startPointOffsetFunc, rotationFunc, pointFunc, segment, zOffset) {
  segmentStart = segment * 3
  startPoint0 = rotationFunc(pointFunc(cornerCurvePoints), 0, segmentStart)
  startPoint = startPointOffsetFunc(startPoint0)
  sweepPath = startSketchOn(offsetPlane('XY', offset = zOffset))
    |> startProfileAt(startPoint, %)
    |> generateBezierCurve(pointFunc(cornerCurvePoints), rotationFunc, segmentStart, %)
  curves = edgeCurves(pointFunc(moreEdgePoints), startPoint[0], zOffset, -startPoint[1])
    |> sweep(path = sweepPath)

  return [curves, sweepPath]
}

fn spOffsetFunc(x, y){
  return fn(xy) {
    return [x+xy[0], y+xy[1]]
  }
}

fn curveGeneratorXYZOffset(rotationFunc, x, y, z){
  return fn(idx) {
    return generateEdgeCornerCurves(
      spOffsetFunc(x,y),
      rotationFunc,
      negativeXList,
      idx,
      z)
  }
}

// 4 upper corner edge curve points
map(
  [0,1,2,3,4,5],
  curveGeneratorXYZOffset(rotatedOffset180Func, 0,0, bodyThickness))
map(
  [0,1,2,3,4,5],
  curveGeneratorXYZOffset(
    rotatedOffset90Func,
    widthWithoutCurve+cornerCurveRadius,
    cornerCurveRadius,
    bodyThickness))
map(
  [0,1,2,3,4,5],
  curveGeneratorXYZOffset(
    rotatedOffset270Func,
    cornerCurveRadius,
    -totalLength+cornerCurveRadius,
    bodyThickness))
map(
  [0,1,2,3,4,5],
  curveGeneratorXYZOffset(
    offsetFunc,
    totalWidth,
    -totalLength+2*cornerCurveRadius,
    bodyThickness))

// /*
// bottom corners
map (
  map(
    [0,1,2,3,4,5],
    curveGeneratorXYZOffset(rotatedOffset180Func, -cornerCurveRadius,-cornerCurveRadius, 0)
  ),
  fn(solidPath) {
    solid = solidPath[0]
    path = solidPath[1]
    |> close()
    |> extrude(length=-bodyThickness)
    |> rotate(roll = 180, pitch = 0, yaw = 270)
    return solid |> rotate(roll = 180, pitch = 0, yaw = 270)
  }
)
map (
  map(
    [0,1,2,3,4,5],
    curveGeneratorXYZOffset(rotatedOffset180Func, -totalWidth, 0, 0)
  ),
  fn(solidPath) {
    solid = solidPath[0]
    path = solidPath[1]
    |> close()
    |> extrude(length=-bodyThickness)
    |> rotate(roll = 180, pitch = 0, yaw = 180)
    return solid |> rotate(roll = 180, pitch = 0, yaw = 180)
  }
)
map (
  map(
    [0,1,2,3,4,5],
    curveGeneratorXYZOffset(rotatedOffset180Func, -lengthWithoutCurve-cornerCurveRadius, totalWidth-cornerCurveRadius, 0)
  ),
  fn(solidPath) {
    solid = solidPath[0]
    path = solidPath[1]
    |> close()
    |> extrude(length=-bodyThickness)
    |> rotate(roll = 180, pitch = 0, yaw = 90)
    return solid |> rotate(roll = 180, pitch = 0, yaw = 90)
  }
)
map (
  map(
    [0,1,2,3,4,5],
    curveGeneratorXYZOffset(rotatedOffset180Func, 0, lengthWithoutCurve, 0)
  ),
  fn(solidPath) {
    solid = solidPath[0]
    path = solidPath[1]
    |> close()
    |> extrude(length=-bodyThickness)
    |> rotate(roll = 180, pitch = 0, yaw = 0)
    return solid |> rotate(roll = 180, pitch = 0, yaw = 0)
  }
)
//*/


fn edgeLineCurvesCurves(points, x, y, z, xyzFuncs) {
  xFunc = xyzFuncs.xFunc
  yFunc = xyzFuncs.yFunc
  zFunc = xyzFuncs.zFunc
  pointFunc = xyzFuncs.pointFunc
  xx = xFunc(x)
  yy = yFunc(y)
  zz = zFunc(z)
  ppoints = pointFunc(points)

  rad = cornerCurveRadius - edgeCurveWidth
  return startSketchOn(offsetPlane('XZ', offset = zz))
    |> startProfileAt([xx, yy], %)
    |> edgeBezCurves(ppoints, offsetFunc, %)
    |> xLine(xFunc(cornerCurveRadius-edgeCurveWidth), %)
    |> yLine(zFunc(-edgeCurveHeight), %)
    |> close()
}

fn generateEdgeCurves(startPointOffsetFunc,
  z,
  length,
  xyzFuncs) {
  startPoint = startPointOffsetFunc([0,0])
  return edgeLineCurvesCurves(moreEdgePoints, startPoint[0], z, -startPoint[1], xyzFuncs)
    |> extrude(length=length)
}

// initial edge
generateEdgeCurves(spOffsetFunc(0,0), bodyThickness, lengthWithoutCurve, {
  xFunc = identity,
  yFunc = identity,
  zFunc = identity,
  pointFunc  = identity,
})

// top edge
generateEdgeCurves(spOffsetFunc(-cornerCurveRadius,totalWidth-cornerCurveRadius), bodyThickness, widthWithoutCurve, {
  xFunc = identity,
  yFunc = identity,
  zFunc = identity,
  pointFunc  = identity,
}) |> rotate(roll = 0, pitch = 00, yaw = 270)

// Bottom edge
generateEdgeCurves(spOffsetFunc(-totalLength+cornerCurveRadius,-cornerCurveRadius), bodyThickness, widthWithoutCurve, {
  xFunc = identity,
  yFunc = identity,
  zFunc = identity,
  pointFunc  = identity,
}) |> rotate(roll = 0, pitch = 00, yaw = 90)

// opposite top edge
generateEdgeCurves(spOffsetFunc(-totalWidth,0), -bodyThickness, lengthWithoutCurve, {
  xFunc = invert,
  yFunc = invert,
  zFunc = identity,
  pointFunc = negativeXList,
})

// /*
// underside edge
generateEdgeCurves(spOffsetFunc(0,0), 0, lengthWithoutCurve, {
  xFunc = identity,
  yFunc = invert,
  zFunc = invert,
  pointFunc = negativeYList,
})

// opposite top edge
generateEdgeCurves(spOffsetFunc(-totalWidth,0), 0, lengthWithoutCurve, {
  xFunc = invert,
  yFunc = invert,
  zFunc = invert,
  pointFunc = negativeXYList,
  pointRotationFunc = identity,
})

// underside top edge
generateEdgeCurves(spOffsetFunc(-totalLength+cornerCurveRadius,cornerCurveRadius), 0, widthWithoutCurve, {
  xFunc = identity,
  yFunc = invert,
  zFunc = invert,
  pointFunc = negativeYList,
}) |> rotate(roll = 0, pitch = 00, yaw = 90)

// underside top edge
generateEdgeCurves(spOffsetFunc(-cornerCurveRadius,-totalWidth+cornerCurveRadius), 0, widthWithoutCurve, {
  xFunc = identity,
  yFunc = invert,
  zFunc = invert,
  pointFunc = negativeYList,
}) |> rotate(roll = 0, pitch = 00, yaw = 270)
//*/

// LENS

cameraEdgeOffset = 1.04
cameraBaseRadius = 14.17 - cameraEdgeOffset
cameraBaseWidth = 45.22 - cameraEdgeOffset
cameraBaseWidthWithoutCurves = cameraBaseWidth - (2*cameraBaseRadius)
cameraBaseLength = 46.45 - cameraEdgeOffset
cameraBaseLengthWithoutCurves = cameraBaseLength - (2*cameraBaseRadius)

cameraPlateauOffset = 4.70
cameraPlateauWidth = 41.56 - cameraPlateauOffset
cameraPlateauWidthWithoutCurves = cameraPlateauWidth - (2*cameraBaseRadius)
camreaPlateauLength = 42.88 - cameraPlateauOffset
cameraPlateauLengthWithoutCurves = camreaPlateauLength - (2*cameraBaseRadius)

cameraPlateauThickness = 2.05
cameraThickness = 4.28 - cameraPlateauThickness

camera1HeightOffset = 14.17
camera1WidthOffset = 14.17
camera2HeightOffset = 33.41
camera2WidthOffset = 14.17
camera3HeightOffset = 23.79
camera3WidthOffset = 32.16

cameraLensDiameter = 16.02
cameraLensRadius = cameraLensDiameter/2



fn cameraBody(x, y, z) {
  cameraBase = startSketchOn(offsetPlane('XY', offset = z))
    |> startProfileAt([x+cameraEdgeOffset, y+cornerCurveRadius-cameraBaseRadius-cameraEdgeOffset], %)
    |> yLine(-cameraBaseLengthWithoutCurves, %, $cameraEdge1)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(cameraBaseWidthWithoutCurves, %,  $cameraEdge2)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> yLine(cameraBaseLengthWithoutCurves, %, $cameraEdge3)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(-cameraBaseWidthWithoutCurves, %,  $cameraEdge4)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> close()

    cameraPlateau0 =startSketchOn(offsetPlane('XY', offset = z+cameraPlateauThickness*0.8))
    |> startProfileAt([x+cameraPlateauOffset, y+cornerCurveRadius-cameraBaseRadius-cameraPlateauOffset], %)
    |> yLine(-cameraPlateauLengthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(cameraPlateauWidthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> yLine(cameraPlateauLengthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(-cameraPlateauWidthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> close()

    cameraPlateau =startSketchOn(offsetPlane('XY', offset = z+cameraPlateauThickness))
    |> startProfileAt([x+cameraPlateauOffset, y+cornerCurveRadius-cameraBaseRadius-cameraPlateauOffset], %)
    |> yLine(-cameraPlateauLengthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(cameraPlateauWidthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> yLine(cameraPlateauLengthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> xLine(-cameraPlateauWidthWithoutCurves, %)
    |> tangentialArc({ radius = cameraBaseRadius, offset = 90 }, %)
    |> close()

    // TODO: do a reverse curve/sweep/extrusion
    lofted = loft(
      [cameraBase, cameraPlateau0,cameraPlateau],
      // baseCurveIndex = 2,
      // bezApproximateRational = true,
      // tolerance = 0.0000001,
      // vDegree = 3,
    )

    return lofted
}

fn lenses(x, y, z) {
  return startSketchOn(offsetPlane('XY', offset = z+totalThickness-edgeCurveHeight+cameraPlateauThickness))
    |> circle({
      center = [x, y+cornerCurveRadius],
      radius = cameraLensRadius,
    }, %)
    |> extrude(%, length = cameraThickness)
}

cameraBase = cameraBody(0,0,totalThickness-edgeCurveHeight)
cameraLens1 = lenses(camera1WidthOffset,-camera1HeightOffset,0)
cameraLens2 = lenses(camera2WidthOffset,-camera2HeightOffset,0)
cameraLens3 = lenses(camera3WidthOffset,-camera3HeightOffset,0)
