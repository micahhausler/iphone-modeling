// iPhone 16 Pro 3D model
// For technical specifications, see page 296-299
// https://developer.apple.com/accessories/Accessory-Design-Guidelines.pdf


cornerCurveRadius = 19.23
totalWidth = 71.45
totalLength = 149.61
bodyLength = -totalLength + cornerCurveRadius * 2

edgeCurveHeight = 2.28
totalThickness = 8.25
bodyThickness = totalThickness - (edgeCurveHeight * 2)

lengthWithoutCurve = totalLength - (cornerCurveRadius * 2)
widthWithoutCurve = totalWidth - (cornerCurveRadius * 2)

edgeCurveWidth = 2.41
widthWithoutEdgeCurve = totalWidth - (edgeCurveWidth * 2)

// 0th and every third point are documented points.
// intermediate points are interpolated
// TODO: migrate python midpoint interpolation to KCL
cornerCurvePoints = [
  [0, 19.23],
  [0.01, 17.41],
  [0.02, 15.58],
  [0.04, 13.75],
  [0.17, 11.92],
  [0.43, 10.12],
  [0.89, 8.36],
  [1.6, 6.68],
  [2.56, 5.13],
  [3.74, 3.74],
  [5.13, 2.56],
  [6.68, 1.6],
  [8.36, 0.89],
  [10.12, 0.43],
  [11.92, 0.17],
  [13.75, 0.04],
  [15.58, 0.02],
  [17.41, 0.01],
  [19.23, 0]
]

// offset returns the relative difference between two points in a list
fn offsetFunc(pts, startIndex, endIndex) {
  r0 = pts[startIndex]
  xx0 = r0[0]
  yy0 = r0[1]
  r1 = pts[endIndex]
  xx1 = r1[0]
  yy1 = r1[1]
  return [xx1 - xx0, yy1 - yy0]
}

// rotatedOffset returns the relative difference between two points in a list, rotated 90 degrees
fn rotatedOffsetFunc(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [-offsetRes[1], offsetRes[0]]
}

// rotatedOffset180 returns the relative difference between two points in a list, rotated 180 degrees
fn rotatedOffset180Func(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [-offsetRes[0], -offsetRes[1]]
}

// rotatedOffset270 returns the relative difference between two points in a list, rotated 270 degrees
fn rotatedOffset270Func(pts, startIndex, endIndex) {
  offsetRes = offsetFunc(pts, startIndex, endIndex)
  return [offsetRes[1], -offsetRes[0]]
}

// cornerBezierCurves returns siz corner bezier curves
fn cornerBezierCurves(pts, offsetFunc, z) {
  return bezierCurve({
         to = offsetFunc(pts, 0, 3),
         control1 = offsetFunc(pts, 0, 1),
         control2 = offsetFunc(pts, 0, 2)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 3, 6),
         control1 = offsetFunc(pts, 3, 4),
         control2 = offsetFunc(pts, 3, 5)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 6, 9),
         control1 = offsetFunc(pts, 6, 7),
         control2 = offsetFunc(pts, 6, 8)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 9, 12),
         control1 = offsetFunc(pts, 9, 10),
         control2 = offsetFunc(pts, 9, 11)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 12, 15),
         control1 = offsetFunc(pts, 12, 13),
         control2 = offsetFunc(pts, 12, 14)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 15, 18),
         control1 = offsetFunc(pts, 15, 16),
         control2 = offsetFunc(pts, 15, 17)
       }, %)
}

// generate iphone body
fn iphoneBody(x, y, z) {
  return startSketchOn(offsetPlane('XY', offset = z))
    |> startProfileAt([x, y], %)
    |> yLine(-lengthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, offsetFunc, %)
    |> xLine(widthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffsetFunc, %)
    |> yLine(lengthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffset180Func, %)
    |> xLine(-widthWithoutCurve, %)
    |> cornerBezierCurves(cornerCurvePoints, rotatedOffset270Func, %)
    |> close()
    |> extrude(length = bodyThickness)
}

phoneBody = iphoneBody(0, 0, 0)

// -------------- Edge --------------
// Edge curve points from diagram
edgePoints = [
  [0, 0.0],
  [0.07, 1.02],
  [0.58, 1.92],
  [1.47, 2.26],
  [2.41, 2.28]
]

// 0th and every third point are documented points.
// intermediate points are interpolated
// TODO: migrate python midpoint interpolation to KCL
moreEdgePoints = [
  [0, 0.0],
  [0.0, 0.34],
  [0.01, 0.68],
  [0.07, 1.02],
  [0.18, 1.36],
  [0.36, 1.67],
  [0.58, 1.92],
  [0.85, 2.1],
  [1.15, 2.2],
  [1.47, 2.26],
  [1.79, 2.28],
  [2.1, 2.28],
  [2.41, 2.28]
]

fn reversePts(xy) {
  return [-xy[0], xy[1]]
}

fn reversePtsY(xy) {
  return [-xy[0], -xy[1]]
}

fn negativeY(xYpts) {
  return [xYpts[0], -xYpts[1]]
}

fn negativeX(xYpts) {
  return [-xYpts[0], xYpts[1]]
}

fn edgeBezCurves(pts, offsetFunc, z) {
  return bezierCurve({
         to = offsetFunc(pts, 0, 3),
         control1 = offsetFunc(pts, 0, 1),
         control2 = offsetFunc(pts, 0, 2)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 3, 6),
         control1 = offsetFunc(pts, 3, 4),
         control2 = offsetFunc(pts, 3, 5)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 6, 9),
         control1 = offsetFunc(pts, 6, 7),
         control2 = offsetFunc(pts, 6, 8)
       }, %)
    |> bezierCurve({
         to = offsetFunc(pts, 9, 12),
         control1 = offsetFunc(pts, 9, 10),
         control2 = offsetFunc(pts, 9, 11)
       }, %)
}

fn reverseOffset(pts, startIndex, endIndex) {
  return offsetFunc(pts, startIndex, endIndex)
    |> reversePts(%)
}

fn reverseOffsetY(pts, startIndex, endIndex) {
  return offsetFunc(pts, startIndex, endIndex)
    |> reversePtsY(%)
}

fn reverseRotatedOffset180(pts, startIndex, endIndex) {
  return rotatedOffset180Func(pts, startIndex, endIndex)
    |> reversePts(%)
}

fn edgeCurves(points, x, y, z) {
  rad = cornerCurveRadius - edgeCurveWidth
  return startSketchOn(offsetPlane('XZ', offset = z))
    |> startProfileAt([x, y], %)
    |> edgeBezCurves(points, offsetFunc, %)
    |> xLine(-rad, %)
    |> yLine(-edgeCurveHeight, %)
    |> close()
}

fn negativeYList(pts) {
  return map(pts, negativeY)
}

fn negativeXList(pts) {
  return map(pts, negativeX)
}

fn pairOffsetxy(pair, x, y) {
  return [pair[0] + x, pair[1] + y]
}
fn pairOffsetX(xy, xOffset) {
  return pairOffsetxy(xy, xOffset, 0)
}
fn pairOffsetY(xy, yOffset) {
  return pairOffsetxy(xy, 0, yOffset)
}

// Generate a bezier curve segment for a sweep Path
fn generateBezierCurve(pts, offsetFunc, ptIdx, z) {
  return bezierCurve({
    to = offsetFunc(pts, ptIdx, ptIdx + 3),
    control1 = offsetFunc(pts, ptIdx, ptIdx + 1),
    control2 = offsetFunc(pts, ptIdx, ptIdx + 2)
  }, %)
}

// edgeCornerCurve draws a corner edge curve
//
// segment is the numeric segment [0-5] of the corner curve
fn generateEdgeCornerCurve(segment) {
  segmentStart = segment * 3
  startPoint = rotatedOffset180Func(  negativeXList(cornerCurvePoints), 0, segmentStart)
  sweepPath = startSketchOn(offsetPlane('XY', offset = bodyThickness))
    |> startProfileAt(startPoint, %)
    |> generateBezierCurve(negativeXList(cornerCurvePoints), rotatedOffset180Func, segmentStart, %)
  return edgeCurves(negativeXList(moreEdgePoints), startPoint[0], bodyThickness, -startPoint[1])
    |> sweep(path = sweepPath)
}

// corner edge swept solids
generateEdgeCornerCurve(0)
generateEdgeCornerCurve(1)
generateEdgeCornerCurve(2)
generateEdgeCornerCurve(3)
generateEdgeCornerCurve(4)
generateEdgeCornerCurve(5)

